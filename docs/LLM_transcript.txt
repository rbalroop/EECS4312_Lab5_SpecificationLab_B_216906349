## Student Name: Richard Balroop
## Student ID: 216906349

Prompt 1: "Copy paste your question"
LLM Response 1: "Copy paste LLMs response"
Why does this code produce a type error:
def test_non_dict_request_raises():
    # Non-Dict Request Raises Error
    # Constraint: structural validation
    # Reason: request must be a dict
    resources = {'cpu': 5}
    requests = [{'cpu': 2}, ['mem', 1]]  # malformed request
    with pytest.raises(ValueError):
        is_allocation_feasible(resources, requests)

TypeError: list indices must be integers or slices, not str
## Student Name: Richard Balroop
## Student ID: 216906349

"""
Stub file for the is allocation feasible exercise.

Implement the function is_allocation_feasible to  Determine whether a set of resource requests can be satisfied 
given limited capacities. Take int account any possible constraints. See the lab handout
for full requirements.
"""
    
from typing import Dict, List, Union

Number = Union[int, float]


def is_allocation_feasible(
    resources: Dict[str, Number],
    requests: List[Dict[str, Number]]
) -> bool:
    """
    Determine whether a set of resource requests can be satisfied given limited capacities.

    Args:
        resources : Dict[str, Number], Mapping from resource name to total available capacity.
        requests : List[Dict[str, Number]], List of requests. Each request is a mapping from resource name to the amount required.

    Returns:
        True if the allocation is feasible, False otherwise.

    """
    flag = True
    for i in range(len(requests)):
        if requests[i] is None or not isinstance(requests[i], dict):
            flag = False
        if not confirm_type_of_key_and_value(requests[i], str, Number):
            flag = False
    if not confirm_type_of_key_and_value(resources, str, Number):
        flag = False
    
    total_requests = build_total_request(requests)
    for key in total_requests:
        if key not in resources or total_requests[key] > resources[key]:
            flag = False
    
    return flag
            
    
    
    # TODO: Implement this function
    # raise NotImplementedError("suggest_slots function has not been implemented yet")

def confirm_type_of_key_and_value(dictionary, expected_key_type, expected_value_type):
    flag = True
    for key in dictionary:
        if not isinstance(key, expected_key_type) or not isinstance(dictionary[key], expected_value_type):
            flag = False
    return flag
    
def build_total_request(requests):
    total_requests = {}
    for request in requests:
        for key in request:
            if key in total_requests:
                total_requests[key] += request[key]
            else:
                total_requests[key] = request[key]
    return total_requests

Because even though you notice a malformed request, you still pass it into confirm_type_of_key_and_value, and that function assumes it’s a dict.

In your failing test:

requests = [{'cpu': 2}, ['mem', 1]]  # <- second item is a list


Loop in is_allocation_feasible:

if requests[i] is None or not isinstance(requests[i], dict):
    flag = False          # i=1 -> True, so flag becomes False
if not confirm_type_of_key_and_value(requests[i], str, Number):
    flag = False          # BUT you still call it!


Now inside confirm_type_of_key_and_value(dictionary= ['mem', 1], ...):

for key in dictionary:    # key becomes 'mem' then 1
    dictionary[key]       # BOOM when key == 'mem'


A list can only be indexed by integers (0, 1, …), not by a string like 'mem', so you get:

TypeError: list indices must be integers or slices, not str

What you intended (raise ValueError for non-dict requests)
Fix: bail out early (raise immediately)

If your requirement is “malformed request raises ValueError”, do this:

def is_allocation_feasible(resources, requests) -> bool:
    if not isinstance(resources, dict):
        raise ValueError("resources must be a dict")
    if not isinstance(requests, list):
        raise ValueError("requests must be a list")

    for req in requests:
        if not isinstance(req, dict):
            raise ValueError("each request must be a dict")
        if not confirm_type_of_key_and_value(req, str, (int, float)):
            raise ValueError("invalid key/value types in request")

    if not confirm_type_of_key_and_value(resources, str, (int, float)):
        raise ValueError("invalid key/value types in resources")

    total_requests = build_total_request(requests)
    for k, v in total_requests.items():
        if k not in resources or v > resources[k]:
            return False

    return True

Minimal patch to your existing structure

If you want to keep flag, at least skip the helper when it’s not a dict:

for req in requests:
    if req is None or not isinstance(req, dict):
        raise ValueError("each request must be a dict")
    if not confirm_type_of_key_and_value(req, str, (int, float)):
        raise ValueError("invalid request types")

Extra: your test function location

That test_non_dict_request_raises() should be in tests/test_solution.py, not inside src/solution.py, and you need:

import pytest


But the TypeError you asked about is specifically due to indexing a list with 'mem'.

If you tell me whether the lab expects “return False” vs “raise ValueError” for malformed inputs, I can match the exact behavior to the rubric.

Now, I get this:
test_solution.py ...F                                                                                                                            [100%]

======================================================================= FAILURES =======================================================================
_____________________________________________________________ test_non_dict_request_raises _____________________________________________________________

    def test_non_dict_request_raises():
        # Non-Dict Request Raises Error
        # Constraint: structural validation
        # Reason: request must be a dict
        resources = {'cpu': 5}
        requests = [{'cpu': 2}, ['mem', 1]]  # malformed request
        with pytest.raises(ValueError):
>           is_allocation_feasible(resources, requests)

test_solution.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
solution.py:36: in is_allocation_feasible
    if not confirm_type_of_key_and_value(requests[i], str, Number):
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dictionary = ['mem', 1], expected_key_type = <class 'str'>, expected_value_type = typing.Union[int, float]

    def confirm_type_of_key_and_value(dictionary, expected_key_type, expected_value_type):
        flag = True
        for key in dictionary:
>           if not isinstance(key, expected_key_type) or not isinstance(dictionary[key], expected_value_type):
                                                                        ^^^^^^^^^^^^^^^
E           TypeError: list indices must be integers or slices, not str

solution.py:57: TypeError
=============================================================== short test summary info ================================================================
FAILED test_solution.py::test_non_dict_request_raises - TypeError: list indices must be integers or slices, not str
============================================================= 1 failed, 3 passed in 0.04s ==============================================================
(.venv) richard_balroop@Richards-MacBook-Pro src % 
This is my updated code:
## Student Name: Richard Balroop
## Student ID: 216906349

"""
Stub file for the is allocation feasible exercise.

Implement the function is_allocation_feasible to  Determine whether a set of resource requests can be satisfied 
given limited capacities. Take int account any possible constraints. See the lab handout
for full requirements.
"""
    
from typing import Dict, List, Union

Number = Union[int, float]


def is_allocation_feasible(
    resources: Dict[str, Number],
    requests: List[Dict[str, Number]]
) -> bool:
    """
    Determine whether a set of resource requests can be satisfied given limited capacities.

    Args:
        resources : Dict[str, Number], Mapping from resource name to total available capacity.
        requests : List[Dict[str, Number]], List of requests. Each request is a mapping from resource name to the amount required.

    Returns:
        True if the allocation is feasible, False otherwise.

    """
    flag = True
    for i in range(len(requests)):
        if requests[i] is None or not isinstance(requests[i], dict):
            flag = False
        if not confirm_type_of_key_and_value(requests[i], str, Number):
            flag = False
    if not confirm_type_of_key_and_value(resources, str, Number):
        flag = False
    
    if flag:
        total_requests = build_total_request(requests)
        for key in total_requests:
            if key not in resources or total_requests[key] > resources[key]:
                flag = False
    
    return flag
            
--------------------------------------------------
Prompt 2: "Copy paste your question"
LLM Response 2: "Copy paste LLMs response"
--------------------------------------------------



You’re still getting the TypeError for the same reason as before: even when a request is not a dict, you still call:

confirm_type_of_key_and_value(requests[i], str, Number)


So when requests[i] is ['mem', 1], your helper tries to do dictionary['mem'] and crashes before you ever return or raise.

Also, your test expects a ValueError, but your function currently just sets flag = False and returns False. So you need to raise when the input structure is invalid.

Minimal fix (matches your test: raise ValueError on malformed request)

Change your loop to “validate then raise immediately”:

def is_allocation_feasible(resources, requests) -> bool:
    # validate resources container
    if resources is None or not isinstance(resources, dict):
        raise ValueError("resources must be a dict")

    if not confirm_type_of_key_and_value(resources, str, (int, float)):
        raise ValueError("invalid resource key/value types")

    # validate requests container
    if requests is None or not isinstance(requests, list):
        raise ValueError("requests must be a list")

    for req in requests:
        if req is None or not isinstance(req, dict):
            raise ValueError("each request must be a dict")
        if not confirm_type_of_key_and_value(req, str, (int, float)):
            raise ValueError("invalid request key/value types")

    # feasibility check
    total_requests = build_total_request(requests)
    for key, amount in total_requests.items():
        if key not in resources or amount > resources[key]:
            return False

    return True


And update your helper to use concrete runtime types (not typing.Union):

def confirm_type_of_key_and_value(dictionary, expected_key_type, expected_value_type):
    for key, value in dictionary.items():
        if not isinstance(key, expected_key_type) or not isinstance(value, expected_value_type):
            return False
    return True

Why you must change Number here

Number = Union[int, float] is a typing object; isinstance(x, Number) is not what you want. Use (int, float) for runtime checks.

If you insist on keeping your “flag” style

At minimum, guard the helper call:

for i in range(len(requests)):
    if requests[i] is None or not isinstance(requests[i], dict):
        raise ValueError("each request must be a dict")
    if not confirm_type_of_key_and_value(requests[i], str, (int, float)):
        raise ValueError("invalid request types")

Bottom line

Your code fails because you call the dict-checking helper on a list.

Your test fails because you don’t raise ValueError for malformed inputs.

Also: don’t use Number in isinstance; use (int, float).

If you paste the top of tests/test_solution.py (especially what it expects for invalid resources/requests), I can match the exact raising/returning behavior to every test.

Prompt 3:
How strong is this code against bugs

"""
Stub file for the is allocation feasible exercise.

Implement the function `is_allocation_feasible` to  Determine whether a set of resource requests can be satisfied 
given limited capacities. Take int account any possible constraints. See the lab handout
for full requirements.
"""
    
from typing import Dict, List, Union

Number = Union[int, float]


def is_allocation_feasible(
    resources: Dict[str, Number],
    requests: List[Dict[str, Number]]
) -> bool:
    """
    Determine whether a set of resource requests can be satisfied given limited capacities.

    Args:
        resources : Dict[str, Number], Mapping from resource name to total available capacity.
        requests : List[Dict[str, Number]], List of requests. Each request is a mapping from resource name to the amount required.

    Returns:
        True if the allocation is feasible, False otherwise.

    """
    flag = True
    for i in range(len(requests)):
        if requests[i] is None or not isinstance(requests[i], dict):
            # Tests if the request is None or not a dictionary
            raise ValueError("Invalid request at index {}: must be a non-null dictionary".format(i))
        if not confirm_type_of_key_and_value(requests[i], str, Number):
            # Tests if the keys and values in the request are of the correct type
            raise ValueError("Invalid type in requests list at index {}".format(i))
        vals = requests[i].values()
        if any(v is None or v < 0 for v in vals):
            # Tests if any value in the request is None or not a positive number
            raise ValueError("Invalid request at index {}: all values must be positive numbers".format(i))

    if not isinstance(resources, dict) or not confirm_type_of_key_and_value(resources, str, Number):
        # Tests if the resources argument is a dictionary and if its keys and values are of the correct type
        raise ValueError("Invalid type in resources dictionary")
    
    
    total_requests = build_total_request(requests)
    for key in total_requests:
        if key not in resources or total_requests[key] > resources[key]:
            flag = False
    
    return flag
            
    
    
    # TODO: Implement this function
    # raise NotImplementedError("suggest_slots function has not been implemented yet")

def confirm_type_of_key_and_value(dictionary, expected_key_type, expected_value_type):
    flag = True
    for key in dictionary:
        if not isinstance(key, expected_key_type) or not isinstance(dictionary[key], expected_value_type):
            flag = False
    return flag
    
def build_total_request(requests):
    total_requests = {}
    for request in requests:
        for key in request:
            if key in total_requests:
                total_requests[key] += request[key]
            else:
                total_requests[key] = request[key]
    return total_requests

Response 3:
It’s a decent start for *basic* cases, but right now it’s **not very strong against bugs**, mainly because one of your key “type checks” will actually **crash at runtime** in normal Python.

## 1) Biggest bug: `typing.Union` can’t be used with `isinstance`

You set:

```python
Number = Union[int, float]
```

and later do:

```python
isinstance(dictionary[key], expected_value_type)
```

But `expected_value_type` is **`typing.Union[...]`**, and Python will raise:

> `TypeError: isinstance() arg 2 must be a type or tuple of types`

So your validator can fail *even for valid input*, depending on how it gets exercised.

✅ Fix: use a runtime-checkable type/tuple:

```python
NumberTypes = (int, float)
# or: from numbers import Real; NumberTypes = (Real,)
```

Then check with `isinstance(x, NumberTypes)`.

---

## 2) Your “positive” check doesn’t match what you wrote

You wrote “must be positive numbers” but you check:

```python
any(v is None or v < 0 for v in vals)
```

That allows `0`. If you truly mean “strictly positive”, use `v <= 0`.

Also: `None` is already blocked by your earlier type check (once it’s fixed), so you can simplify.

---

## 3) Missing validations that can turn into weird failures

A few common edge cases:

* If `requests` is `None` or not a list → `len(requests)` throws a `TypeError` (not your `ValueError`).
* You don’t validate `resources` values are **non-negative** (a negative capacity is nonsense, but would pass your current check once fixed).
* `bool` values pass `isinstance(True, int)` (because `bool` is a subclass of `int`). So `True` could be treated like `1` unless you explicitly reject it.
* `float("nan")` and `float("inf")` pass `isinstance(v, float)` but break comparisons or feasibility logic in surprising ways.

---

## 4) Logic: feasible vs invalid input

Right now, unknown resource keys in requests make feasibility `False`:

```python
if key not in resources ...
    flag = False
```

That might be correct, but some specs prefer raising an error for “unknown resource name”. Just make sure it matches your lab handout.

---

# A more robust version (same structure, fewer bug traps)

```python
from numbers import Real
from math import isfinite
from typing import Dict, List

def is_allocation_feasible(resources: Dict[str, Real], requests: List[Dict[str, Real]]) -> bool:
    # Validate requests container
    if not isinstance(requests, list):
        raise ValueError("requests must be a list of dicts")

    # Validate resources container
    if not isinstance(resources, dict):
        raise ValueError("resources must be a dict")

    # Validate resources contents
    for k, v in resources.items():
        if not isinstance(k, str):
            raise ValueError("resources keys must be str")
        if not isinstance(v, Real) or isinstance(v, bool) or not isfinite(v) or v < 0:
            raise ValueError("resources values must be finite, non-negative numbers")

    totals: Dict[str, float] = {}

    # Validate each request and accumulate
    for i, req in enumerate(requests):
        if not isinstance(req, dict):
            raise ValueError(f"Invalid request at index {i}: must be a dict")
        for k, v in req.items():
            if not isinstance(k, str):
                raise ValueError(f"Invalid key type in request {i}")
            if not isinstance(v, Real) or isinstance(v, bool) or not isfinite(v) or v < 0:
                raise ValueError(f"Invalid value in request {i}: must be finite, non-negative numbers")
            totals[k] = totals.get(k, 0.0) + float(v)

    # Feasibility check
    for k, needed in totals.items():
        if k not in resources or needed > resources[k]:
            return False
    return True
```

If your lab truly wants “no value is **<= 0**” instead of “no value is < 0”, change the `v < 0` checks to `v <= 0`.

---

If you paste the lab’s exact constraints (especially around “unknown resource keys” and whether `0` is allowed), I can tighten this to match the spec exactly.

Prompt 4: 